# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00a_video_compression.ipynb (unless otherwise specified).

__all__ = ['get_file_size', 'runnit', 'vid_colour_primaries', 'vid_is_HDR', 'get_mediainfo', 'show_vid_info',
           'run_ffmpeg', 'origfake_exist', 'load_dfdc_json', 'get_cvant_paper', 'compress_vids']

# Cell
from IPython.display import HTML
import cv2
from fastai.core import *
from fastai.vision import *
from .data import *

# Cell
def get_file_size(fpath):
    assert fpath.is_file()
    p = subprocess.run(f"du -hs {fpath}".split(), stdout=subprocess.PIPE)
    return p.stdout.decode().split('\t')[0]

# Cell
Path.file_size = get_file_size

# Cell
def runnit(f):
    def _func(*args, **kwargs):
        command = f(*args, **kwargs)
        p = subprocess.run(command.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        return p
    return _func

# Cell
@runnit
def vid_colour_primaries(fpath):
    "Use `mediainfo` to get video's colour primaries."
    return f'''
    mediainfo f'{fpath}' --Inform="Video;%colour_primaries%"
    '''

def vid_is_HDR(fpath):
    "Is video HDR or not?"
    p = vid_colour_primaries(fpath)
    res = p.stdout.decode()
    return True if 'BT.2020' in res else False

# Cell
def get_mediainfo(fpath=None):
    @runnit
    def _func(fpath=None):
        return f'''mediainfo {fpath}'''
    p = _func(fpath=fpath)
    return p.stdout.decode()

# Cell
def show_vid_info(f):
    "Display video and its properties after it's been processed."
    def _f(*args, **kwargs):
        p = f(*args, **kwargs)
        fpath = Path(kwargs['fpath_to'])
        display(HTML(html_vid(fpath)))
        print(get_mediainfo(fpath))
    return _f

# Cell
def _ffmpeg_web_defaults():
    '''
    These are some reasonable values for uploading. i.e. YouTube, etc.
    '''
    return dict(video_encoder='libx264', video_bitrate='1.5M', fps=30, scale=.5, crf=23, #17-28
                audio_encoder='aac', audio_bitrate='128k')

def _ffmpeg_defaults():
    return dict(video_encoder=None, video_bitrate=None, fps=None, scale=None, crf=None,
                audio_encoder=None, audio_bitrate=None)

def _ffmpeg_fmts():
    "ffmpeg options syntax"
    return dict(video_encoder='-c:v {video_encoder:s}',
                video_bitrate='-b:v {video_bitrate:s}',
                fps='-r {fps:d}',
                scale='-vf scale=iw*{scale:.2f}:ih*{scale:.2f}',
                crf='-crf {crf:d}',
                audio_bitrate='-b:a {audio_bitrate}',
                audio_encoder='-c:a {audio_encoder}')

#@show_vid_info
@runnit
def run_ffmpeg(fpath_from=None, fpath_to=None, **kwargs):
    '''
    Run ffmpeg
    '''
    ps = _ffmpeg_defaults()
    ps.update(kwargs)
    pstr = []
    for n, s in _ffmpeg_fmts().items():
        if ps[n] is None: pstr.append('')
        else: pstr.append(s.format(**ps))
    pstr = ' '.join(pstr)
    return f'ffmpeg -i {fpath_from} {pstr} {fpath_to}'

# Cell
def origfake_exist(row):
    fake_exists = row.fname.exists()
    orig_exists = True if pd.isna(row.original) else row.original.exists()
    return (fake_exists and orig_exists)

def load_dfdc_json(path, dfdc, fpath=False, drop_missing=False, fill_real_na=False):
    a = get_files(path/dfdc, extensions=['.json'])[0]
    a = pd.read_json(a).T
    a.reset_index(inplace=True)
    a.rename({'index':'fname'}, axis=1, inplace=True)
    if fpath or drop_missing:
        a.fname = a.fname.apply(lambda o: path/dfdc/o)
        a.original = a.original.apply(lambda o: np.nan if pd.isna(o) else path/dfdc/o)
    if drop_missing:
        exists = a.apply(origfake_exist, axis=1)
        a = a[exists].reset_index(drop=True)
    if fill_real_na:
        ao = a[a.label=='REAL'].copy()
        ao.drop('original', axis=1, inplace=True)
        ao['original'] = ao.fname.copy()
        a[a.label=='REAL'] = ao
    return a

# Cell
def get_cvant_paper(vant:pd.DataFrame, fnos:list):
    '''
    Get compressed video annotation, `cvant`, according to
    the DFDC paper.
    vant: video annotation
    fnos: iterable of original video names
    '''
    encs = list(ENC_DICT.keys()) + ['None']
    idxs = torch.randperm(len(fnos))
    chidxs = torch.chunk(idxs, len(encs))
    vantps = []
    for enc, idxs in zip(encs, chidxs):
        vantp = vant.set_index('original').loc[fnos[idxs]]
        vantp['enc'] = enc
        vantp = vantp.reset_index()
        vantps.append(vantp)
    cvant = pd.concat(vantps)
    return cvant

# Cell
def compress_vids(cvant, dir_out='compressed_videos'):
    '''
    Compress videos, save them and the annotation.
    '''
    dir_out = Path(dir_out)
    os.makedirs(dir_out, exist_ok=True)
    cvant['fname_cv'] = cvant.fname.apply(lambda o: dir_out/o.name)
    pb = progress_bar(list(cvant.iterrows()))
    for _, r in pb:
        if r.enc=='None':
            shutil.copy(r.fname, r.fname_cv)
        else:
            run_ffmpeg(fpath_from=r.fname, fpath_to=r.fname_cv, **ENC_DICT[r.enc])
        pb.comment = f'{r.fname.name} {r.enc}'
    cvant.to_csv(dir_out/'metadata.csv', index=False)
    return cvant