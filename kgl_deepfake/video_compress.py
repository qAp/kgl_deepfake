# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00a_video_compression.ipynb (unless otherwise specified).

__all__ = ['get_file_size', 'runnit', 'vid_colour_primaries', 'vid_is_HDR', 'get_mediainfo', 'show_vid_info',
           'run_ffmpeg', 'origfake_exist', 'load_dfdc_json', 'compress_dataset']

# Cell
from IPython.display import HTML
import cv2
from fastai.core import *
from fastai.vision import *
from .data import *

# Cell
def get_file_size(fpath):
    assert fpath.is_file()
    p = subprocess.run(f"du -hs {fpath}".split(), stdout=subprocess.PIPE)
    return p.stdout.decode().split('\t')[0]

# Cell
Path.file_size = get_file_size

# Cell
def runnit(f):
    def _func(*args, **kwargs):
        command = f(*args, **kwargs)
        p = subprocess.run(command.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        return p
    return _func

# Cell
@runnit
def vid_colour_primaries(fpath):
    "Use `mediainfo` to get video's colour primaries."
    return f'''
    mediainfo f'{fpath}' --Inform="Video;%colour_primaries%"
    '''

def vid_is_HDR(fpath):
    "Is video HDR or not?"
    p = vid_colour_primaries(fpath)
    res = p.stdout.decode()
    return True if 'BT.2020' in res else False

# Cell
def get_mediainfo(fpath=None):
    @runnit
    def _func(fpath=None):
        return f'''mediainfo {fpath}'''
    p = _func(fpath=fpath)
    return p.stdout.decode()

# Cell
def show_vid_info(f):
    "Display video and its properties after it's been processed."
    def _f(*args, **kwargs):
        p = f(*args, **kwargs)
        fpath = Path(kwargs['fpath_to'])
        display(HTML(html_vid(fpath)))
        print(get_mediainfo(fpath))
    return _f

# Cell
def _ffmpeg_web_defaults():
    '''
    These are some reasonable values for uploading. i.e. YouTube, etc.
    '''
    return dict(video_encoder='libx264', video_bitrate='1.5M', fps=30, scale=.5, crf=23, #17-28
                audio_encoder='aac', audio_bitrate='128k')

def _ffmpeg_defaults():
    return dict(video_encoder=None, video_bitrate=None, fps=None, scale=None, crf=None,
                audio_encoder=None, audio_bitrate=None)

def _ffmpeg_fmts():
    "ffmpeg options syntax"
    return dict(video_encoder='-c:v {video_encoder:s}',
                video_bitrate='-b:v {video_bitrate:s}',
                fps='-r {fps:d}',
                scale='-vf scale=iw*{scale:.2f}:ih*{scale:.2f}',
                crf='-crf {crf:d}',
                audio_bitrate='-b:a {audio_bitrate}',
                audio_encoder='-c:a {audio_encoder}')

#@show_vid_info
@runnit
def run_ffmpeg(fpath_from=None, fpath_to=None, **kwargs):
    '''
    Run ffmpeg
    '''
    ps = _ffmpeg_defaults()
    ps.update(kwargs)
    pstr = []
    for n, s in _ffmpeg_fmts().items():
        if ps[n] is None: pstr.append('')
        else: pstr.append(s.format(**ps))
    pstr = ' '.join(pstr)
    return f'ffmpeg -i {fpath_from} {pstr} {fpath_to}'

# Cell
def origfake_exist(row):
    fake_exists = row.fname.exists()
    orig_exists = True if pd.isna(row.original) else row.original.exists()
    return (fake_exists and orig_exists)

def load_dfdc_json(path, dfdc, fpath=False, drop_missing=False):
    a = get_files(path/dfdc, extensions=['.json'])[0]
    a = pd.read_json(a).T
    a.reset_index(inplace=True)
    a.rename({'index':'fname'}, axis=1, inplace=True)
    if fpath or drop_missing:
        a.fname = a.fname.apply(lambda o: path/dfdc/o)
        a.original = a.original.apply(lambda o: np.nan if pd.isna(o) else path/dfdc/o)
    if drop_missing:
        exists = a.apply(origfake_exist, axis=1)
        return a[exists].reset_index(drop=True)
    return a

def compress_dataset(path, dfdc, enc, copy_json=True):
    annots = load_dfdc_json(path, dfdc, drop_missing=True)
    fn_froms = list(annots.fname)
    dir_to = path/f'{dfdc}_{enc}'
    os.makedirs(dir_to, exist_ok=True)
    fn_tos = [dir_to/o.name for o in fn_froms]
    for i in progress_bar(range(len(fn_froms))):
        fpath_from, fpath_to = fn_froms[i], fn_tos[i]
        if fpath_to.exists(): os.remove(fpath_to)
        run_ffmpeg(fpath_from=fpath_from, fpath_to=fpath_to, **ENC_DICT[enc])
    if copy_json: shutil.copy(path/dfdc/'metadata.json', dir_to/'metadata.json')
    return dir_to