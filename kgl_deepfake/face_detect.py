# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/organising_face_detection_results.ipynb (unless otherwise specified).

__all__ = ['COLS_BOX', 'COLS_PROB', 'COLS_ANT', 'box2facedf', 'vid2frames', 'vid2facedf', 'filter_by_prob',
           'add_box_area', 'filter_by_area', 'add_box_center', 'sort_boxc', 'box_procs', 'process_boxs', 'hvize_coords',
           'hv_overlay_box', 'hv_overlay_boxs', 'hv_boxs_on_frame', 'frame2face', 'hv_overlay_faceinfo', 'hv_face',
           'hv_face_roll']

# Cell
import sys
sys.path.append('../face_detection')
from IPython.display import *
from fastai.core import *
from fastai.vision import *
from facenet_pytorch import *
from tqdm.notebook import tqdm
import mmcv, cv2
from EasyMTCNN import EasyMTCNN
from EasyRetinaFace import EasyRetinaFace
from .data import *
from .video_compress import *
import holoviews as hv

# Cell
COLS_BOX = ['x0', 'y0', 'x1', 'y1']
COLS_PROB = ['prob']
COLS_ANT = ['frame', 'face'] + COLS_BOX + COLS_PROB

# Cell
def box2facedf(iframe, boxes, probs):
    data = np.concatenate([boxes, probs[:,None]], axis=1)
    df = pd.DataFrame(data, columns=COLS_BOX+COLS_PROB)
    df['face'] = np.array(range_of(probs), dtype=np.int32)[:,None]
    df['frame'] = iframe
    return df[COLS_ANT]

# Cell
def vid2frames(fn, iframes):
    vid = mmcv.VideoReader(str(fn))
    idx_frames = ((i, o) for i, o in enumerate(vid) if i in iframes)
    iframes, frames = zip(*idx_frames)
    frames = (PIL.Image.fromarray(cv2.cvtColor(o, cv2.COLOR_BGR2RGB)) for o in frames)
    return iframes, frames

# Cell
def vid2facedf(fn, iframes, detect):
    iframes, frames = vid2frames(fn, iframes)
    df = pd.DataFrame(columns=COLS_ANT)
    for i in range_of(iframes):
        res = detect(np.array(next(frames)))
        if len(res) == 0: continue
        boxs, probs = res[:,:4], res[:,4]
        df = df.append(box2facedf(iframes[i], boxs, probs))
    return df.reset_index(drop=True)

# Cell
def filter_by_prob(df):
    thres = .90
    df = df[df.prob > thres].copy()
    return df.reset_index(drop=True)

# Cell
def add_box_area(df):
    if df.shape[0] > 0:
        df['area'] = df.apply(lambda o: (o.x1-o.x0)*(o.y1-o.y0), axis=1)
    else:
        df = pd.DataFrame(columns=list(df.columns.values) + ['area'])
    return df

# Cell
def filter_by_area(df):
    dl = .23
    m = df.area.mean()
    lower_cond = ((1 - dl)**2 * m <= df.area)
    upper_cond = (df.area <= (1 + dl)**2 * m)
    return df[lower_cond & upper_cond].copy().reset_index(drop=True)

# Cell
def add_box_center(df):
    if df.shape[0] > 0:
        df['xc'] = df.apply(lambda o: .5*(o.x0+o.x1), axis=1)
        df['yc'] = df.apply(lambda o: .5*(o.y0+o.y1), axis=1)
    else:
        df = pd.DataFrame(columns=list(df.columns.values) + ['xc', 'yc'])
    return df

# Cell
def sort_boxc(df):
    '''Re-order each frame's boxes by their center's (x, y) coordinates'''
    if df.shape[0] > 0:
        df = df.groupby('frame').apply(lambda o: o.sort_values(['xc', 'yc'], axis=0))
        df.index.rename(None, level=0, inplace=True)
        df = df.reset_index(drop=True)
        df['reset_face'] = df.groupby('frame').face.transform(lambda o: np.arange(o.shape[0]))
        df.drop('face', axis=1, inplace=True)
        df.rename({'reset_face':'face'}, axis=1, inplace=True)
        columns = list(df.columns.values)
        columns = [columns[0]] + [columns[-1]] + columns[1:-1]
        df = df[columns]
    return df

# Cell
box_procs = [filter_by_prob, add_box_area, filter_by_area, add_box_center, sort_boxc]

# Cell
def process_boxs(df):
    df = df.copy(deep=True)
    for f_ in box_procs: df = f_(df)
    return df

# Cell
def hvize_coords(r, size):
    width, height = size
    r = r.copy()
    for o in ['x0', 'xc', 'x1']: r[o] = -.5 + r[o] / width
    for o in ['y0', 'yc', 'y1']: r[o] = .5 - r[o] / height
    r['area'] = r.area / (size[0]*size[1])
    return r

# Cell
def hv_overlay_box(elem, r, frame_size):
    nr = hvize_coords(r, frame_size)
    box = hv.Box(nr.xc, nr.yc, (nr.x1 - nr.x0, nr.y1 - nr.y0))
    faceid = hv.Text(nr.xc, nr.yc, f'{int(r.face):d}')
    return elem * (box * faceid)

def hv_overlay_boxs(elem, df, frame_size):
    if df.shape[0] == 0: return elem
    for i, r in df.iterrows():
        elem = hv_overlay_box(elem, r, frame_size)
    return elem

def hv_boxs_on_frame(frame, df):
    elem = hv.RGB(np.array(frame))
    elem = hv_overlay_boxs(elem, df, frame.size)
    elem = elem.opts(hv.opts.Box(color='red'),
                     hv.opts.Text(color='cyan'))
    w, h = (int(.25 * o) for o in frame.size)
    elem.opts(width=w, height=h, xaxis=None, yaxis=None)
    return elem

# Cell
def frame2face(frame, r):
    r = r.squeeze()
    x0, y0, x1, y1 = r[['x0', 'y0', 'x1', 'y1']].astype(np.int32)
    dx, dy = frame.size
    x0, y0 = max(x0, 0), max(y0, 0)
    x1, y1 = min(x1, dx - 1), min(y1, dy - 1)
    return np.array(frame)[y0:y1,x0:x1]

# Cell
def hv_overlay_faceinfo(r):
    frameface = hv.Text(-.38, .45, f'{int(r.frame)}:{int(r.face)}')
    prob = hv.Text(.35, .45, f'{r.prob:.4f}')
    info = frameface * prob
    info = info.opts(hv.opts.Text(color='cyan', text_font_size='7.5pt'))
    return info

def hv_face(faceimg, r=None):
    fig = hv.RGB(faceimg)
    if r is not None: fig = fig * hv_overlay_faceinfo(r)
    fig = fig.opts(xaxis=None, yaxis=None, width=150, height=150)
    return fig

# Cell
def hv_face_roll(fn, df):
    figs = []
    iframes, frames = vid2frames(fn, df.frame.unique())
    for iframe in iframes:
        frame = next(frames)
        for i, r in df[df.frame==iframe].iterrows():
            faceimg = frame2face(frame, r)
            figs.append(hv_face(faceimg, r))
    return figs