# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/fake_original.ipynb (unless otherwise specified).

__all__ = ['align_frameface', 'stack_origfake_facedfs', 'origfake_facedf', 'annots2facedf', 'load_face_annot',
           'row2faceimgpath', 'save_faceimgs']

# Cell
import sys
sys.path.append('../face_detection')
import IPython.display as display
from fastai.core import *
from fastai.vision import *
from facenet_pytorch import *
from EasyMTCNN import EasyMTCNN
from EasyRetinaFace import EasyRetinaFace
import cv2, mmcv
import holoviews as hv
from .data import *
from .face_detect import *
from .video_compress import *

# Cell
def align_frameface(dfo, *dffs):
    cols_ff = ['frame', 'face']
    cols = list(dfo.columns[2:])
    # Merge all dataframes
    df = dfo.copy(deep=True)
    for i, dff in enumerate(dffs):
        df = df.merge(dff,
                      left_on=['frame', 'face'], right_on=['frame', 'face'],
                      how='inner', suffixes=('', f'_{i}'))

    # Split back into ORIGINAL + FAKEs
    rdfo = df[cols_ff + cols]
    rdffs = []
    for i in range_of(dffs):
        rdff = df[cols_ff + [f'{o}_{i}' for o in cols]]
        rdff.columns = cols_ff + cols
        rdffs.append(rdff)
    return rdfo, rdffs

# Cell
def stack_origfake_facedfs(fno:str, dfo, fnfs:list, dffs:list):
    '''
    Stack together the face_df of an ORIGINAL and those of its FAKEs.
    fno: str
        File path of ORIGINAL.
    dfo: pd.DataFrame
        `facedf` of ORIGINAL.
    '''
    dfo, dffs = dfo.copy(), [df.copy() for df in dffs]
    dfo['label'] = 'REAL'
    dfo['fname'], dfo['original'] = fno, fno
    for fn, df in zip(fnfs, dffs):
        df['label'] = 'FAKE'
        df['fname'], df['original'] = fn, fno
    return pd.concat([dfo] + dffs, axis=0).reset_index(drop=True)

# Cell
def origfake_facedf(fno, fnfs, detect, iframes=None, proc_boxs=True, inner_ff=True):
    if iframes is None: iframes = [0,]
    facedfs = []
    for fn in [fno] + list(fnfs):
        df = vid2facedf(fn, iframes, detect)
        if proc_boxs: df = process_boxs(df)
        facedfs.append(df)
    dfo, dffs = facedfs[0], facedfs[1:]
    if inner_ff: dfo, dffs = align_frameface(dfo, *dffs)
    return stack_origfake_facedfs(fno, dfo, fnfs, dffs)

# Cell
def annots2facedf(annot, detect, iframes=None, proc_boxs=True, inner_ff=True):
    '''
    Return dataframe consisting of stacked facedfs
    for all ORIGINALs and their FAKEs.
    annots: pd.DataFrame
        Only FAKE videos, no REAL videos where `original` is NaN.
    '''
    if iframes is None: iframes = [0]
    dfs = []
    pb = progress_bar(annot.groupby('original'))
    for fno, ann in pb:
        fnfs = [r.fname for _, r in ann.iterrows()]
        ifrms = iframes(ann.iloc[0]) if callable(iframes) else iframes
        df = origfake_facedf(fno, fnfs, detect, proc_boxs=proc_boxs, inner_ff=inner_ff, iframes=ifrms)
        dfs.append(df)
        pb.comment = f'Original {fno}. Number of FAKEs: {len(ann)}'
    return pd.concat(dfs).reset_index(drop=True)

# Cell
def load_face_annot(csv):
    df = pd.read_csv(csv)
    for c in ['fname', 'original', 'fname_face']:
        df[c] = df[c].apply(lambda o: Path(o))
    return df

# Cell
def row2faceimgpath(path, r):
    r['fname'] = Path(r.fname)
    return path/f'{r.fname.stem}_frame{r.frame}_face{r.face}_{r.label}.png'

# Cell
def save_faceimgs(tot_facedf):
    vidns = tot_facedf.fname.unique()
    mb = master_bar(vidns)
    for vidn in mb:
        df_vid = tot_facedf[tot_facedf.fname==vidn]
        iframes = df_vid.frame.unique()
        iframes, frames = vid2frames(vidn, iframes)
        for iframe in progress_bar(iframes, parent=mb):
            frame = next(frames)
            df_frame = df_vid[df_vid.frame==iframe]
            for _, r in df_frame.iterrows():
                faceimg = frame2face(frame, r)
                PIL.Image.fromarray(faceimg).save(r.fname_face)
            mb.child.comment = f'frame {iframe}'
        mb.main_bar.comment = f'video {vidn}'